name: AddPost → Default PR 자동 생성

on:
  push:
    branches:
      - addPost # addPost에 push될 때만 실행

permissions:
  contents: write # 코드 접근용
  pull-requests: write # PR 생성 권한

concurrency:
  group: addPost-ci
  cancel-in-progress: true

jobs:
  ci:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      # - uses: actions/setup-node@v4
      #   with:
      #     node-version: 20
      #     cache: yarn

      # - name: Install deps
      #   run: yarn --frozen-lockfile

      # - name: Lint
      #   run: yarn lint

      # - name: Build
      #   run: yarn build

  create_pr:
    needs: ci
    runs-on: ubuntu-latest
    steps:
      - name: Create Pull Request to default branch if missing
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const { owner, repo } = context.repo;
            const head = 'addPost';
            const base = (await github.rest.repos.get({ owner, repo })).data.default_branch;

            // 열려있는 PR 가져오기 (head/base 조합)
            const { data: prs } = await github.rest.pulls.list({
              owner, repo, state: 'open', head: `${owner}:${head}`, base
            });
            if (prs.length === 0) {
              core.setFailed('No open PR to merge.');
              return;
            }
            const prNumber = prs[0].number;

            // 최대 60초 폴링
            let pr, tries = 0;
            while (tries < 30) {
              pr = (await github.rest.pulls.get({ owner, repo, pull_number: prNumber })).data;
              core.info(`mergeable=${pr.mergeable} state=${pr.mergeable_state} draft=${pr.draft}`);

              if (pr.draft) {
                core.setFailed('PR is draft. Abort merging.');
                return;
              }

              // 아직 계산 중
              if (pr.mergeable === null) {
                await new Promise(r => setTimeout(r, 2000));
                tries++; continue;
              }

              // 뒤처짐이면 최신화 시도
              if (pr.mergeable_state === 'behind') {
                core.info('PR is behind base. Trying to update branch...');
                try {
                  await github.rest.pulls.updateBranch({ owner, repo, pull_number: prNumber });
                  await new Promise(r => setTimeout(r, 4000));
                } catch (e) {
                  core.warning(`updateBranch failed: ${e.message}`);
                }
                tries++; continue;
              }

              // 컨플릭트/차단은 실패 처리
              if (pr.mergeable_state === 'dirty') {
                core.setFailed('Merge conflict (dirty). Resolve conflicts manually.');
                return;
              }
              if (pr.mergeable_state === 'blocked') {
                core.setFailed('Blocked by required checks/reviews or unresolved conversations.');
                return;
              }

              // 머지 가능
              if (pr.mergeable === true && ['clean','has_hooks','unstable'].includes(pr.mergeable_state)) {
                break;
              }

              await new Promise(r => setTimeout(r, 2000));
              tries++;
            }

            if (!pr || pr.mergeable !== true) {
              core.setFailed(`Not mergeable after waiting. state=${pr?.mergeable_state}`);
              return;
            }

            await github.rest.pulls.merge({
              owner, repo, pull_number: prNumber, merge_method: 'squash'
            });
            core.info(`✅ Merged PR #${prNumber}`);
